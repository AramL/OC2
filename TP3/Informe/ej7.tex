\section{Ejercicio 7.}

\subsection*{g)}

\noindent Para este punto, se agrego las variables $debugMode$ y $debugView$. La primera indica si se entro en modo debug, y la segunda indica si en este momento se esta mostrando informacion en la pantalla. \\

\noindent Luego se cambiaron tanto la rutina de atencion de interrupciones de teclado, para agregar la tecla Y, la cual setea estas variables, como el macro para la atencion de excepciones. Este se modifico para que en caso de encontrarse en modo debug, se cree una copia de la pantalla, y luego se proceda a mostrar la informacion de la excepcion requerida por el enunciado. \\

\noindent Se utilizo un arreglo para mantener una copia de la pantalla anterior.

\begin{codesnippet}
\begin{verbatim}
    short pantalla[80 * 50];
    .....
    .....
void game_guardar_pantalla() {
    short *src = (short *)0xB8000;
    int i;
    for(i = 0; i < 80 * 50; i++){
        pantalla[i] = src[i];
     }
}
\end{verbatim}
\end{codesnippet}

\noindent Para la rutina de atencion de interrupciones del reloj, se modifico para que en caso de encontrarse en debug, no se ejecute el salto de tarea sino que se espera hasta que se desactive el mismo.
\begin{codesnippet}
\begin{verbatim}
        cmp dword [debug_mode],0
        je .continuar
        cmp dword [debug_view], 1
		je .fin
.continuar:
        ....
        rutina de atencion reloj
        ....
.fin:
        popad  
        iret
\end{verbatim}
\end{codesnippet}

\noindent Para escribir los estados de los flags, como de los registros, los mismos se pushean a la pila y se pasan por parametro para luego imprimirlos por pantalla.

\begin{codesnippet}
\begin{verbatim}
    mov eax, [esp]
    pushf 									
    push eax
    call game_imprimir_info_debug
\end{verbatim}
\end{codesnippet}
